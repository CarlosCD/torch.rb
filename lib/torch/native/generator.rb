require "yaml"
require "torch/native/function"

module Torch
  module Native
    module Generator
      class << self
        def generate_cpp_functions
          functions = grouped_functions
          generate_cpp_file("torch", :define_singleton_method, functions[:torch])
          generate_cpp_file("tensor", :define_method, functions[:tensor])
          generate_cpp_file("nn", :define_singleton_method, functions[:nn])
        end

        def grouped_functions
          functions = functions()

          # remove functions
          skip_binding = ["unique_dim_consecutive", "einsum", "normal"]
          skip_args = ["bool[", "Dimname", "ScalarType", "MemoryFormat", "Storage", "ConstQuantizerPtr"]
          functions.reject! { |f| f.ruby_name.start_with?("_") || f.ruby_name.end_with?("_backward") || skip_binding.include?(f.ruby_name) }
          todo_functions, functions =
            functions.partition do |f|
              skip_args.any? { |v| f.args_str.include?(v) } ||
              f.parsed_args.any? { |a| a[:type].include?("?") && !["Tensor?", "Generator?"].include?(a[:type]) }
            end

          # todo_functions.each do |f|
          #   puts f.func
          #   puts
          # end

          nn_functions, other_functions = functions.partition { |f| f.python_module == "nn" }
          torch_functions = other_functions.select { |f| f.variants.include?("function") }
          tensor_functions = other_functions.select { |f| f.variants.include?("method") }

          {torch: torch_functions, tensor: tensor_functions, nn: nn_functions}
        end

        private

        def generate_cpp_file(type, def_method, functions)
          template = <<-TEMPLATE
// generated by rake generate:functions
// do not edit by hand

#include <torch/torch.h>
#include <rice/Module.hpp>
#include "templates.hpp"

void add_%{type}_functions(Module m) {
  m
  %{functions};
}
        TEMPLATE

          cpp_defs = []
          functions.sort_by(&:cpp_name).each do |func|
            fargs = func.parsed_args.select { |a| a[:type] != "Generator?" }

            cpp_args = []
            fargs.each do |a|
              t =
                case a[:type]
                when "Tensor"
                  "const Tensor &"
                when "Tensor?"
                  # TODO better signature
                  "OptionalTensor"
                when "Tensor[]"
                  "TensorList"
                when "int"
                  "int64_t"
                when "float"
                  "double"
                when /\Aint\[/
                  "IntArrayRef"
                when /Tensor\(\S!?\)/
                  "Tensor &"
                else
                  a[:type]
                end

              t = "MyReduction" if a[:name] == "reduction" && t == "int64_t"
              cpp_args << [t, a[:name]].join(" ").sub("& ", "&")
            end

            dispatch = func.out? ? "#{func.base_name}_out" : func.base_name
            args = fargs.map { |a| a[:name] }
            args.unshift(*args.pop(func.out_size)) if func.out?
            args.delete("self") if def_method == :define_method

            prefix = def_method == :define_method ? "self." : "torch::"

            cpp_defs << ".#{def_method}(
    \"#{func.cpp_name}\",
    *[](#{cpp_args.join(", ")}) {
      return #{prefix}#{dispatch}(#{args.join(", ")});
    })"
          end

          path = File.expand_path("../../../ext/torch/#{type}_functions.cpp", __dir__)
          File.write(path, template % {type: type, functions: cpp_defs.join("\n  ")})
        end

        def functions
          @native_functions ||= YAML.load_file(path).map { |f| Function.new(f) }
        end

        def path
          File.expand_path("native_functions.yaml", __dir__)
        end
      end
    end
  end
end
